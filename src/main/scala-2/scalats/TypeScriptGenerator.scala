package scalats

import java.io.{File, PrintStream}
import scala.reflect.runtime.universe._

object TypeScriptGenerator {
  def isTypeConstructor(t: Type): Boolean =
    t =:= t.typeConstructor && t.takesTypeArgs

  def maybeTypeConstructor(t: Type): Type =
    if (t.typeArgs.nonEmpty) t.typeConstructor else t

  def looseTpeEq(t1: Type, t2: Type): Boolean =
    t1 =:= t2 ||
      (isTypeConstructor(t1) && !isTypeConstructor(t2) && t1 =:= t2.typeConstructor) ||
      (t1.typeSymbol.isClass && t1.typeSymbol.asClass.isSealed && maybeTypeConstructor(t2) <:< maybeTypeConstructor(t1))

  class TypeToFile(pairs: List[(Type, String)]) {
    def getT(tpe: Type): Option[(Type, String)] =
      pairs.collect { case (t, f) if looseTpeEq(t, tpe) => (t, f) }.groupBy(_._2).map(_._2.head).toList match {
        case t :: Nil => Option(t)
        case ts @ (_ :: _ :: _) => sys.error(s"Type $tpe found in more than one file: ${ts.map(_._2).mkString(", ")}")
        case Nil => None
      }

    def get(tpe: Type): Option[String] = getT(tpe).map(_._2)

    def forFile(file: String): List[Type] =
      pairs.collect { case (t, f) if f == file => t }

    lazy val allFiles: Set[String] = pairs.map(_._2).toSet
  }

  object TypeToFile {
    def build(basePath: File, files: Map[String, List[Type]]): TypeToFile =
      new TypeToFile(files.toList.flatMap { case (f, types) => types.map(tpe => tpe -> (s"$basePath/$f")) })
  }

  def referenceCode(
    basePath: File,
    currFile: File,
    generatedFiles: Map[String, List[Type]],
    tpe: Type,
    logger: Logger,
    classLoader: ClassLoader = getClass.getClassLoader,
    customImport: (String, String) => (TsImports, String) = (file, name) => (TsImports.names(file, name), name),
  )(implicit config: Config): (Map[String, TsImport], String) = {
    val typeToFile = TypeToFile.build(basePath, generatedFiles)
    val scalaParser = new ScalaParser(logger, runtimeMirror(classLoader), config.excludeType)
    val scalaType = typeToFile.getT(tpe).fold(tpe.dealias)(_._1)
    val scalaTypeRef = scalaParser.getTypeRef(scalaType, scalaParser.getTypeParams(scalaType))
    val tsTypeRef = Compiler(config).compileTypeRef(scalaTypeRef, false)
    val emitter = new IoTsEmitter(config)
    val (imports, code) = emitter.getIoTsTypeString(tsTypeRef)(
      TsImports.Ctx((tpe, name) => typeToFile.get(tpe).map(customImport(_, name))))
    (
      imports.foldLeft(Map.empty[String, TsImport])((acc, i) => acc + (i.path(currFile, typeToFile.allFiles) -> i.run)),
      code,
    )
  }

  def generateFiles(
    basePath: File,
    files: Map[String, List[Type]],
    logger: Logger,
    classLoader: ClassLoader = getClass.getClassLoader
  )(implicit config: Config): Unit = {
    val mirror = runtimeMirror(classLoader)
    val typeToFile = TypeToFile.build(basePath, files)

    files.foreach { case (fileName, _) =>
      val file = new File(s"$basePath/$fileName")
      file.getParentFile.mkdirs()
      file.createNewFile()
      val outputStream = new PrintStream(file)

      val excludeType = (t: Type) => config.excludeType(t) || typeToFile.get(t).exists(_ != file.toString)
      val scalaParser = new ScalaParser(logger, mirror, excludeType)
      val scalaTypes = scalaParser.parseTypes(typeToFile.forFile(file.toString))

      outputStream.println("/**********************************************************")
      outputStream.println(" *                                                        *")
      outputStream.println(" *    FILE GENERATED BY SCALA-TS. DO NOT EDIT BY HAND.    *")
      outputStream.println(" *                                                        *")
      outputStream.println(" *********************************************************/")
      outputStream.println()

      val emitter = new IoTsEmitter(config)
      val compiledTypes = Compiler(config).compile(scalaTypes)
      val compiledTypeNames = compiledTypes.map(_.name.toLowerCase).toSet
      val (imports, lines) = emitter.emit(compiledTypes)(TsImports.Ctx((tpe, name) =>
        typeToFile.get(tpe).map { f =>
          val alias = s"${f.split('/').last.split('.').head}_${name}"

          if (compiledTypeNames.contains(name.toLowerCase) && f != file.toString)
            (TsImports.names(f.toString, s"$name as $alias"), alias)
          else
            (TsImports.names(f.toString, name), name)
        }))

      imports.foreach(i => i.asString(file, typeToFile.allFiles).foreach(outputStream.println(_)))
      outputStream.println()

      lines.foreach(outputStream.println)
      outputStream.println()
    }
  }
}
