package com.mpc.scalats.core

import com.mpc.scalats.configuration.Config
import scala.reflect.runtime.universe._
import scala.util.{Failure, Success, Try}

/**
  * Created by Milosz on 11.06.2016.
  */
object TypeScriptGenerator {

  private def updateConfig(c: Config): Config = {
    if (c.emitIoTs) {
      c.copy(
        emitClasses = false,
        emitInterfaces = true,
        optionToNullable = false,
        optionToUndefined = false)
    } else {
      c
    }
  }

  def normalizeName(packagePath: Option[String], simpleName: String) =
    s"${packagePath.getOrElse("")}.${Option(simpleName).getOrElse("")}".stripPrefix(".")

  def reflectType(mirror: Mirror)(packagePath: Option[String], simpleName: String): Symbol =
    (packagePath match {
      case Some(p) => Try(mirror.staticModule(p)).getOrElse(mirror.staticPackage(p))
      case None => mirror.staticPackage("scala")
    }).typeSignature.member(TypeName(simpleName))

  def reflectModule(mirror: Mirror)(packagePath: Option[String], simpleName: String): Symbol =
    mirror.staticModule(normalizeName(packagePath, simpleName))

  def reflectClass(mirror: Mirror)(packagePath: Option[String], simpleName: String): Symbol =
    mirror.staticClass(normalizeName(packagePath, simpleName))

  val reflectTypes = List("class" -> reflectClass _, "module" -> reflectModule _, "type" -> reflectType _)

  def tryReflect(mirror: Mirror)(packagePath: Option[String], simpleName: String): Try[Symbol] = {
    val name = normalizeName(packagePath, simpleName)
    reflectTypes.zipWithIndex.foldLeft(Failure(new Throwable): Try[Symbol]) { case (acc, ((tpe, fn), i)) =>
      acc.orElse {
        reflectTypes.lift(i - 1).foreach { case (t, _) => println(s"Could not find $t $name, trying as $tpe") }
        Try(fn(mirror)(packagePath, simpleName))
      }
    }
  }

  val classNameRx = """^((?:([^\.]+(?:\.[^\.]+)*)\.)?([a-zA-Z0-9]+))(?:\[(.*)\])?$""".r

  def getTypeFromName(mirror: Mirror)(className: String): Type =
    className match {
      case classNameRx(_, packagePath, simpleName, typeParamsStr) =>
        val typeParams = ScalaParser.parseTypeParams(typeParamsStr).map(getTypeFromName(mirror))
        val tpe = tryReflect(mirror)(Option(packagePath), simpleName) match {
          case Success(m: ModuleSymbol) => m.moduleClass.asType.toType
          case Success(s) => appliedType(s, typeParams)
          case Failure(th) => throw new Throwable(s"Failed to parse type $className", th)
        }

        (if (typeParams.isEmpty && tpe.typeParams.nonEmpty) tpe.typeConstructor else tpe)//.map(_.dealias)

      case _ => sys.error(s"Something went wrong, unable to parse `$className`")
    }

  def generateFromClassNames(
    classNames: List[String],
    excludeClassNames: List[String],
    logger: Logger,
    classLoader: ClassLoader = getClass.getClassLoader
  )(c: Config) = {
    val mirror = runtimeMirror(classLoader)
    val types = classNames.map(cn => {
      println(s"className = $cn")
      getTypeFromName(mirror)(cn)
    })
    val excludeTypes = excludeClassNames.map(cn => {
      println(s"exclude className = $cn")
      getTypeFromName(mirror)(cn)
    })

    generate(types, excludeTypes, logger, mirror)(updateConfig(c))
  }

  def generate(caseClasses: List[Type], excludeCaseClasses: List[Type], logger: Logger, mirror: Mirror)(c: Config) = {
    implicit val config: Config = updateConfig(c)
    val outputStream = config.outputStream.getOrElse(Console.out)
    val scalaParser = new ScalaParser(logger, mirror, excludeCaseClasses)
    val scalaTypes = scalaParser.parseTypes(caseClasses)
    val typeScriptInterfaces = Compiler.compile(scalaTypes)

    outputStream.println("/**********************************************************")
    outputStream.println(" *                                                        *")
    outputStream.println(" *    FILE GENERATED BY SCALA-TS. DO NOT EDIT BY HAND.    *")
    outputStream.println(" *                                                        *")
    outputStream.println(" *********************************************************/")
    outputStream.println()

    val emitter: Emitter = if (config.emitIoTs) {
      if (config.tsImports.iots) {
        outputStream.println("""import * as t from "io-ts";""")
      }
      if (config.tsImports.iotsDate) {
        outputStream.println("""import { DateFromISOString } from "io-ts-types/lib/DateFromISOString";""")
      }
      if (config.tsImports.iotsNonEmptyArray) {
        outputStream.println("""import { nonEmptyArray } from "io-ts-types/lib/nonEmptyArray";""")
      }
      if (config.tsImports.iotsNumberFromString) {
        outputStream.println("""import { NumberFromString } from "io-ts-types/lib/NumberFromString";""")
      }
      if (config.tsImports.iotsEither) {
        outputStream.println("""import { either } from "io-ts-types/lib/either";""")
      }
      if (config.tsImports.iotsOption) {
        outputStream.println("""import { optionFromNullable } from "io-ts-types/lib/optionFromNullable";""")
      }
      config.tsImports.customImports.foreach(outputStream.println)

      outputStream.println()

      new IoTsEmitter(config)
    } else {
      new TypeScriptEmitter(config)
    }

    emitter.emit(typeScriptInterfaces, outputStream)
  }
}
