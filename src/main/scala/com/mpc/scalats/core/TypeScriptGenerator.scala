package com.mpc.scalats.core

import com.mpc.scalats.configuration.Config
import java.io.{File, PrintStream}
import scala.reflect.runtime.universe._

object TypeScriptGenerator {
  def isTypeConstructor(t: Type): Boolean =
    t =:= t.typeConstructor && t.takesTypeArgs

  def maybeTypeConstructor(t: Type): Type =
    if (t.typeArgs.nonEmpty) t.typeConstructor else t

  def looseTpeEq(t1: Type, t2: Type): Boolean =
    t1 =:= t2 ||
      (isTypeConstructor(t1) && !isTypeConstructor(t2) && t1 =:= t2.typeConstructor) ||
      (t1.typeSymbol.isClass && t1.typeSymbol.asClass.isSealed && maybeTypeConstructor(t2) <:< maybeTypeConstructor(t1))

  class TypeToFile(pairs: List[(Type, String)]) {
    def get(tpe: Type): Option[String] =
      pairs.collect { case (t, f) if looseTpeEq(t, tpe) => f }.distinct match {
        case s :: Nil => Option(s)
        case ss @ (_ :: _ :: _) => sys.error(s"Type $tpe found in more than one file: ${ss.mkString(", ")}")
        case Nil => None
      }

    def forFile(file: String): List[Type] =
      pairs.collect { case (t, f) if f == file => t }

    lazy val allFiles: Set[String] = pairs.map(_._2).toSet
  }

  def generateFiles(
    basePath: File,
    files: Map[String, List[Type]],
    logger: Logger,
    classLoader: ClassLoader = getClass.getClassLoader
  )(implicit config: Config): Unit = {
    val mirror = runtimeMirror(classLoader)
    val filePath = (n: String) => s"$basePath/$n"

    val typeToFile = new TypeToFile(files.toList.flatMap { case (f, types) =>
      types.map(tpe => tpe -> filePath(f))
    })

    files.foreach { case (fileName, _) =>
      val file = new File(filePath(fileName))
      file.getParentFile.mkdirs()
      file.createNewFile()
      val outputStream = new PrintStream(file)

      val excludeType = (t: Type) => config.excludeType(t) || typeToFile.get(t).exists(_ != file.toString)
      val scalaParser = new ScalaParser(logger, mirror, excludeType)
      val scalaTypes = scalaParser.parseTypes(typeToFile.forFile(file.toString))

      outputStream.println("/**********************************************************")
      outputStream.println(" *                                                        *")
      outputStream.println(" *    FILE GENERATED BY SCALA-TS. DO NOT EDIT BY HAND.    *")
      outputStream.println(" *                                                        *")
      outputStream.println(" *********************************************************/")
      outputStream.println()

      val emitter = new IoTsEmitter(config)
      val compiledTypes = Compiler(config).compile(scalaTypes)
      val compiledTypeNames = compiledTypes.map(_.name.toLowerCase).toSet
      val (imports, lines) = emitter.emit(compiledTypes)(TsImports.Ctx((tpe, name) =>
        typeToFile.get(tpe).map { f =>
          val alias = s"${f.split('/').last.split('.').head}_${name}"

          if (compiledTypeNames.contains(name.toLowerCase) && f != file.toString)
            (TsImports.names(f.toString, s"$name as $alias"), alias)
          else
            (TsImports.names(f.toString, name), name)
        }))

      imports.foreach(i => i.asString(file, typeToFile.allFiles).foreach(outputStream.println(_)))
      outputStream.println()

      lines.foreach(outputStream.println)
      outputStream.println()
    }
  }
}
